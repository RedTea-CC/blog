# 总结







# TO DO LIST
"Talk is cheap, show me the code. "



 
# STUDY


## Cocos

## 解构赋值

### 绑定和赋值

对于对象和数组的解构，有两种解构模式：_绑定模式_和_赋值模式_，它们的语法略有不同。

在绑定模式中，模式以声明关键字（`var`、`let` 或 `const`）开始。然后，每个单独的属性必须绑定到一个变量或进一步解构。

在赋值模式中，模式不以关键字开头。每个解构属性都被赋值给一个赋值目标——这个赋值目标可以事先用 `var` 或 `let` 声明，也可以是另一个对象的属性——一般来说，可以是任何可以出现在赋值表达式左侧的东西。
<font color=#F36208>在解构的同时进行属性重命名和赋值</font>。
```js
const numbers = [];
const obj = { a: 1, b: 2 };
({ a: numbers[0], b: numbers[1] } = obj);
// 将 `obj` 对象中的 `a` 和 `b` 属性值分别赋给 `numbers[0]` 和 `numbers[1]` 变量：
```

> **备注：** 当使用对象文字解构赋值而不带声明时，在赋值语句周围必须添加括号 `( ... )`。
`{ a, b } = { a: 1, b: 2 }` 不是有效的独立语法，因为左侧的 `{a, b}` 被视为块而不是对象字面量。但是，`({ a, b } = { a: 1, b: 2 })` 是有效的，`const { a, b } = { a: 1， b: 2 }` 也是有效的。
如果你的编码风格不包括尾随分号，则 `( ... )` 表达式前面需要有一个分号，否则它可能用于执行前一行的函数。

### 默认值

每个解构属性都可以有一个_默认值_。当<font color=#F36208>属性不存在或值为 `undefined`</font> 时，将使用默认值。
<font color=#F36208>如果属性的值为 `null`，则不使用默认值。</font>默认值可以是任何表达式。
```js
// 默认值
const [a = 1] = []; // a is 1
const { b = 2 } = { b: undefined }; // b is 2
const { c = 2 } = { c: null }; // c is null

// 剩余属性
onst { a, ...others } = { a: 1, b: 2, c: 3 };
console.log(others); // { b: 2, c: 3 }
```
### 剩余属性

使用剩余属性（`...rest`）结束解构模式。此模式会将对象或数组的所有剩余属性存储到新的对象或数组中。
<font color=#F36208>剩余属性必须是模式中的最后一个，并且不能有尾随逗号</font>。

### 示例
#### 解构比源更多的元素
在从赋值语句右侧指定的长度为 _N_ 的数组解构的数组中，如果赋值语句左侧指定的变量数量大于 _N_，则只有前 _N_ 个变量被赋值。其余变量的值将是未定义。

#### 交换变量
可以在一个解构表达式中交换两个变量的值。

#### 解析一个从函数返回的数组
从一个函数返回一个数组是十分常见的情况。解构使得处理返回值为数组时更加方便。

#### 忽略某些返回值
你可以忽略你不感兴趣的返回值。

#### 使用绑定模式作为剩余属性
<font color=#F36208>数组</font>解构赋值的剩余属性可以是另一个数组或对象绑定模式。这允许你同时提取数组的属性和索引。
```js
const [a, b, ...[c, d, ...[e, f]]] = [1, 2, 3, 4, 5, 6];
console.log(a, b, c, d, e, f); // 1 2 3 4 5 6

```
另一方面，对象解构只能有一个标识符作为剩余属性。

#### 在任何可迭代对象上使用数组解构
数组解构调用右侧的[迭代协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)。因此，任何可迭代对象（不一定是数组）都可以解构。